<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>PreguntaGo - PMV</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#2ecc71">
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:12px;background:#f4f6f8;color:#222}
  .card{background:#fff;padding:12px;border-radius:8px;margin:10px 0;box-shadow:0 1px 4px rgba(0,0,0,0.06)}
  #gameArea{background:#111;height:320px;border-radius:8px;position:relative;overflow:hidden}
  #player{
    position:absolute;width:44px;height:44px;bottom:8px;
    left:50%;transform:translateX(-50%);background:#2ecc71;border-radius:6px;
    display:flex;align-items:center;justify-content:center;font-weight:bold;color:#043;
    touch-action: none;
  }
  .ob{position:absolute;width:40px;height:40px;background:#e74c3c;border-radius:6px;}
  #modal{position:fixed;left:0;right:0;top:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:40}
  .modalContent{background:#fff;padding:12px;border-radius:8px;width:90%;max-width:420px}
  .controls{margin-top:8px;display:flex;gap:8px}
  .btn{padding:8px 10px;border-radius:6px;border:0;background:#2ecc71;color:#003;cursor:pointer}
  .btn.secondary{background:#3498db;color:#fff}
  .touch-controls{display:flex;gap:8px;margin-top:8px}
  .touch-controls button{flex:1;padding:10px;border-radius:6px;border:0;background:#ddd}
  #qList div{margin-bottom:6px}
</style>
</head>
<body>
<h1>PreguntaGo (PMV)</h1>

<div class="card">
  <strong>Banco de preguntas</strong>
  <textarea id="qtext" rows="2" style="width:100%" placeholder="Pregunta..."></textarea>
  <input id="qtime" placeholder="Tiempo segundos" style="width:120px;margin-top:8px">
  <button id="addQ" class="btn">Agregar pregunta</button>
  <div id="qList" style="margin-top:8px"></div>
</div>

<div class="card">
  <strong>Juego</strong>
  <div id="gameArea"><div id="player">P</div></div>

  <div class="controls">
    <button id="startBtn" class="btn">Iniciar</button>
    <button id="stopBtn" class="btn secondary">Detener</button>
    <button id="resetBtn" class="btn" style="background:#e74c3c;color:#fff">Reset datos</button>
  </div>

  <!-- Controles táctiles para móvil -->
  <div class="touch-controls">
    <button id="leftTouch">◀</button>
    <button id="rightTouch">▶</button>
  </div>
</div>

<div id="modal">
  <div class="modalContent">
    <div id="qBox"></div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="solvedBtn" class="btn">Ya lo hice</button>
      <button id="showAnsBtn" class="btn secondary">Mostrar respuesta</button>
    </div>
    <div style="margin-top:8px">Tiempo: <span id="timer">0</span>s</div>
  </div>
</div>

<div class="card">
  <strong>Stats</strong>
  <div id="stats">Puntos: <span id="points">0</span> | Sesiones: <span id="played">0</span></div>
</div>

<script>
/* -------------------------
   Almacenamiento y render
   ------------------------- */
const STORAGE_KEY = 'preguntago_v1';
function loadData(){
  try{
    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {questions:[], points:0, sessions:0};
  }catch(e){ return {questions:[], points:0, sessions:0}; }
}
function saveData(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }

let data = loadData();
const qListEl = document.getElementById('qList');

function escapeHtml(s){
  return (s+'').replace(/[&<>"']/g, function(m){
    return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m];
  });
}

function renderQ(){
  qListEl.innerHTML = '';
  if(!data.questions || data.questions.length === 0){
    qListEl.innerHTML = '<div style="color:#666">No hay preguntas</div>';
    return;
  }
  data.questions.forEach((q,i)=>{
    const d = document.createElement('div');
    d.style.padding = '6px';
    d.innerHTML = '<strong>Q'+(i+1)+' ('+(q.time||30)+'s)</strong><div>'+escapeHtml(q.text)+'</div>' +
                  '<button data-i="'+i+'" class="del" style="margin-top:6px">Eliminar</button>';
    qListEl.appendChild(d);
  });
  Array.from(document.getElementsByClassName('del')).forEach(b=>{
    b.onclick = ()=>{
      data.questions.splice(+b.dataset.i,1);
      saveData(); renderQ();
    };
  });
}

/* -------------------------
   Elementos del juego
   ------------------------- */
const gameArea = document.getElementById('gameArea');
const player = document.getElementById('player');
const modal = document.getElementById('modal');
const qBox = document.getElementById('qBox');
const timerEl = document.getElementById('timer');

let running = false;
let obstacles = [];
let rafId = null;
let spawnCounter = 0;
let currentQIndex = -1;
let modalTimer = null;
let modalTime = 0;
let points = data.points || 0;

/* Parámetros ajustables */
const PLAYER_SPEED = 12;     // px por movimiento de tecla
const SPAWN_EVERY = 50;      // frames entre posibles spawns (más pequeño = más obstáculos)
const OB_MIN_SPEED = 1.2;
const OB_MAX_SPEED = 3.2;

/* Posicionar jugador inicialmente (centrado en X) */
function centerPlayer(){
  // Dejamos transform translateX(-50%) en CSS para centrar; establecemos una posición base
  player.style.left = (gameArea.clientWidth/2 - player.clientWidth/2) + 'px';
}
centerPlayer();
window.addEventListener('resize', centerPlayer);

/* Movimiento lateral (teclado y táctil) */
function movePlayerBy(dx){
  const minX = 0;
  const maxX = gameArea.clientWidth - player.clientWidth;
  let cur = player.offsetLeft;
  cur = Math.max(minX, Math.min(maxX, cur + dx));
  player.style.left = cur + 'px';
}
window.addEventListener('keydown', (e)=>{
  if(!running) return;
  if(e.key === 'ArrowLeft') { movePlayerBy(-PLAYER_SPEED); e.preventDefault(); }
  else if(e.key === 'ArrowRight'){ movePlayerBy(PLAYER_SPEED); e.preventDefault(); }
});

/* Touch controls */
document.getElementById('leftTouch').addEventListener('touchstart', (e)=>{ e.preventDefault(); if(running) movePlayerBy(-PLAYER_SPEED); });
document.getElementById('rightTouch').addEventListener('touchstart', (e)=>{ e.preventDefault(); if(running) movePlayerBy(PLAYER_SPEED); });

/* Generar obstáculos: spawnear en distintos x del borde superior */
function spawnObstacle(){
  const ob = document.createElement('div');
  ob.className = 'ob';
  const width = 40;
  // spawn en un x aleatorio dentro del área (con margen para no salirse)
  const x = Math.random() * (gameArea.clientWidth - width);
  const startY = -60; // fuera del área
  ob.style.left = x + 'px';
  ob.style.top = startY + 'px';
  gameArea.appendChild(ob);
  const speed = OB_MIN_SPEED + Math.random() * (OB_MAX_SPEED - OB_MIN_SPEED);
  obstacles.push({el: ob, x: x, y: startY, w: width, h: width, speed: speed});
}

/* Detección de colisión simple (AABB) */
function rectsIntersect(a, b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* Loop principal */
function loop(){
  if(!running) return;
  spawnCounter++;
  if(spawnCounter % SPAWN_EVERY === 0){
    spawnObstacle();
  }

  // mover obstáculos y comprobar colisiones
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.y += o.speed;
    o.el.style.top = o.y + 'px';

    // remover si se sale por debajo
    if(o.y > gameArea.clientHeight + 80){
      o.el.remove();
      obstacles.splice(i,1);
      continue;
    }

    // colisión con jugador
    const playerRect = {
      x: player.offsetLeft,
      y: player.offsetTop,
      w: player.clientWidth,
      h: player.clientHeight
    };
    const obRect = {x: o.x, y: o.y, w: o.w, h: o.h};
    if(rectsIntersect(playerRect, obRect)){
      // colisión -> detener juego y abrir modal
      stopGame();
      onCollision();
      return;
    }
  }

  rafId = requestAnimationFrame(loop);
}

/* Iniciar / detener / reset */
function startGame(){
  if(running) return;
  running = true;
  data.sessions = (data.sessions || 0) + 1;
  saveData();
  updateStats();
  // limpiar obstaculos previos
  obstacles.forEach(o=>o.el.remove());
  obstacles = [];
  spawnCounter = 0;
  rafId = requestAnimationFrame(loop);
}
function stopGame(){
  running = false;
  if(rafId) cancelAnimationFrame(rafId);
  rafId = null;
}
function resetData(){
  if(!confirm('Resetear datos?')) return;
  data = {questions:[], points:0, sessions:0};
  saveData();
  renderQ();
  updateStats();
  alert('Reset OK');
}

/* Cuando ocurre una colisión: mostrar modal con pregunta (si hay) o aviso */
function onCollision(){
  if(!data.questions || data.questions.length === 0){
    alert('¡Choque! No hay preguntas guardadas — juego detenido.');
    return;
  }
  // elegir pregunta aleatoria
  currentQIndex = Math.floor(Math.random() * data.questions.length);
  const q = data.questions[currentQIndex];
  qBox.innerHTML = '<strong>Pregunta:</strong><p>' + escapeHtml(q.text) + '</p>';
  modal.style.display = 'flex';
  modalTime = q.time || 30;
  timerEl.textContent = modalTime;
  if(modalTimer) clearInterval(modalTimer);
  modalTimer = setInterval(()=>{
    modalTime--;
    timerEl.textContent = modalTime;
    if(modalTime <= 0){
      clearInterval(modalTimer);
      modalTimer = null;
      timeoutModal();
    }
  }, 1000);
}

/* Cerrar modal y reanudar juego */
function closeModalAndResume(){
  modal.style.display = 'none';
  if(modalTimer) { clearInterval(modalTimer); modalTimer = null; }
  // reanudar juego solo si quedan preguntas o si el usuario quiere seguir
  running = true;
  rafId = requestAnimationFrame(loop);
}

/* Timeout de modal: penaliza y reanuda */
function timeoutModal(){
  data.points = Math.max(0, (data.points||0) - 1);
  saveData(); updateStats();
  modal.style.display = 'none';
  alert('Se acabó el tiempo. Penalizado');
  // no reanudar automáticamente: dejamos que el usuario inicie de nuevo
  running = false;
}

/* Botones del modal */
document.getElementById('solvedBtn').onclick = ()=>{
  data.points = (data.points||0) + 1;
  // eliminar la pregunta respondida
  if(currentQIndex >= 0 && currentQIndex < data.questions.length){
    data.questions.splice(currentQIndex, 1);
  }
  saveData(); renderQ(); updateStats();
  modal.style.display = 'none';
  alert('Bien! punto sumado');
  // no reanudar automáticamente para que el usuario decida
};

document.getElementById('showAnsBtn').onclick = ()=>{ alert('No hay respuesta guardada'); };

/* Actualizar estadísticas en la UI */
function updateStats(){
  document.getElementById('points').textContent = data.points || 0;
  document.getElementById('played').textContent = data.sessions || 0;
}

/* -------------------------
   Evento UI
   ------------------------- */
document.getElementById('addQ').onclick = ()=>{
  const t = document.getElementById('qtext').value.trim();
  const time = parseInt(document.getElementById('qtime').value) || 30;
  if(!t){ alert('Escribe la pregunta'); return; }
  data.questions.push({text: t, time: time});
  saveData(); renderQ();
  document.getElementById('qtext').value = '';
  document.getElementById('qtime').value = '';
};

document.getElementById('startBtn').onclick = startGame;
document.getElementById('stopBtn').onclick = stopGame;
document.getElementById('resetBtn').onclick = resetData;

/* Inicialización */
renderQ();
updateStats();
centerPlayer();

/* Service Worker (opcional) */
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('./sw.js')
    .then(()=> console.log('Service worker registrado'))
    .catch(e => console.log('Service worker fallo', e));
}
<script>
// Parche mínimo para mover el jugador con ← → y con botones táctiles.
// Requiere que exista en el HTML: #gameArea y #player.
// Si ya tienes lógica, puede que debas adaptar nombres/estilos.

const player = document.getElementById('player');
const gameArea = document.getElementById('gameArea');
if (player && gameArea) {
  const STEP = 12; // píxeles por tecla
  // centrar si no tiene posición
  if (!player.style.left) {
    player.style.left = (gameArea.clientWidth/2 - player.clientWidth/2) + 'px';
    player.style.position = 'absolute';
    player.style.bottom = '8px';
  }

  function moveBy(dx) {
    const minX = 0;
    const maxX = gameArea.clientWidth - player.clientWidth;
    let x = player.offsetLeft + dx;
    if (x < minX) x = minX;
    if (x > maxX) x = maxX;
    player.style.left = x + 'px';
  }

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') { moveBy(-STEP); e.preventDefault(); }
    if (e.key === 'ArrowRight'){ moveBy(STEP); e.preventDefault(); }
  });

  // Si quieres botones táctiles en la UI, crea dos botones con estos IDs:
  const leftBtn = document.getElementById('leftTouch');
  const rightBtn = document.getElementById('rightTouch');
  if (leftBtn && rightBtn) {
    leftBtn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); moveBy(-STEP); });
    rightBtn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); moveBy(STEP); });
  }

  // Ajustar al cambiar tamaño
  window.addEventListener('resize', ()=> {
    const cur = player.offsetLeft;
    const maxX = gameArea.clientWidth - player.clientWidth;
    if (cur > maxX) player.style.left = maxX + 'px';
  });
} else {
  console.warn('Parche mínimo: falta #player o #gameArea en la página');
}
</script>
</body>
</html>

